<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plasma Waves - GLSL Shader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            width: 100vw;
            height: 100vh;
            background: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    
    <script>
        // Vertex shader program - simple pass-through
        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() {
                gl_Position = aVertexPosition;
            }
        `;

        // Fragment shader program - plasma waves
        const fsSource = `
            precision highp float;
            
            uniform vec2 uResolution;
            uniform float uTime;
            
            // Plasma wave function
            float plasma(vec2 uv, float time) {
                float value = 0.0;
                
                // Multiple sine waves creating interference patterns
                value += sin(uv.x * 10.0 + time);
                value += sin(uv.y * 10.0 + time * 1.2);
                value += sin((uv.x + uv.y) * 8.0 + time * 0.8);
                value += sin(length(uv) * 12.0 - time * 2.0);
                
                // Add circular waves
                vec2 center1 = vec2(sin(time * 0.5) * 0.3, cos(time * 0.7) * 0.3);
                vec2 center2 = vec2(cos(time * 0.3) * 0.4, sin(time * 0.4) * 0.4);
                
                value += sin(length(uv - center1) * 15.0 - time * 3.0) * 0.5;
                value += sin(length(uv - center2) * 12.0 + time * 2.5) * 0.5;
                
                // Add some turbulence
                value += sin(uv.x * 20.0 + sin(uv.y * 15.0 + time)) * 0.3;
                value += cos(uv.y * 18.0 + cos(uv.x * 12.0 - time)) * 0.3;
                
                return value;
            }
            
            // Color mapping function
            vec3 colorMap(float value) {
                // Normalize value to 0-1 range
                value = (value + 4.0) / 8.0;
                value = fract(value); // Keep it in 0-1 range
                
                // Create a vibrant color palette
                vec3 color1 = vec3(0.1, 0.0, 0.5);  // Deep blue
                vec3 color2 = vec3(0.9, 0.0, 0.5);  // Magenta
                vec3 color3 = vec3(1.0, 0.5, 0.0);  // Orange
                vec3 color4 = vec3(1.0, 1.0, 0.2);  // Yellow
                vec3 color5 = vec3(0.0, 1.0, 0.5);  // Cyan
                
                vec3 color;
                
                if (value < 0.25) {
                    color = mix(color1, color2, value * 4.0);
                } else if (value < 0.5) {
                    color = mix(color2, color3, (value - 0.25) * 4.0);
                } else if (value < 0.75) {
                    color = mix(color3, color4, (value - 0.5) * 4.0);
                } else {
                    color = mix(color4, color5, (value - 0.75) * 4.0);
                }
                
                // Add some brightness variation
                color *= 0.8 + 0.4 * sin(value * 3.14159 * 2.0);
                
                return color;
            }
            
            void main() {
                // Normalize coordinates to -1 to 1
                vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution) / min(uResolution.x, uResolution.y);
                
                // Calculate plasma value
                float value = plasma(uv, uTime);
                
                // Map to color
                vec3 color = colorMap(value);
                
                // Add some glow effect
                float glow = 1.0 + 0.3 * sin(value * 2.0 + uTime);
                color *= glow;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        let gl;
        let programInfo;
        let startTime;

        function initWebGL() {
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                alert('Unable to initialize WebGL. Your browser may not support it.');
                return false;
            }
            
            return true;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            
            return shaderProgram;
        }

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            
            // Full screen quad
            const positions = [
                -1.0,  1.0,
                 1.0,  1.0,
                -1.0, -1.0,
                 1.0, -1.0,
            ];
            
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            return {
                position: positionBuffer,
            };
        }

        function resizeCanvas() {
            const canvas = document.getElementById('glCanvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function drawScene(gl, programInfo, buffers, time) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(programInfo.program);
            
            // Set up position attribute
            {
                const numComponents = 2;
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
            }
            
            // Set uniforms
            gl.uniform2f(programInfo.uniformLocations.resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(programInfo.uniformLocations.time, time);
            
            // Draw
            {
                const offset = 0;
                const vertexCount = 4;
                gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);
            }
        }

        function render(currentTime) {
            const time = (currentTime - startTime) * 0.001; // Convert to seconds
            
            drawScene(gl, programInfo, buffers, time);
            
            requestAnimationFrame(render);
        }

        // Initialize everything
        if (initWebGL()) {
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            
            programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    resolution: gl.getUniformLocation(shaderProgram, 'uResolution'),
                    time: gl.getUniformLocation(shaderProgram, 'uTime'),
                },
            };
            
            const buffers = initBuffers(gl);
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            startTime = performance.now();
            requestAnimationFrame(render);
        }
    </script>
</body>
</html>