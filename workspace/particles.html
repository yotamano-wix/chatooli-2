<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Comet Brush — Rainbow Trails (p5.js)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.3/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #050508;
    }
    canvas { display: block; }
    .hud {
      position: fixed;
      left: 12px;
      bottom: 12px;
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: rgba(255,255,255,0.65);
      user-select: none;
      pointer-events: none;
      mix-blend-mode: screen;
      text-shadow: 0 0 12px rgba(120,180,255,0.25);
    }
  </style>
</head>
<body>
  <div class="hud">Move mouse • Hold click = boost • C = clear</div>

  <script>
    // --- Comet brush particle system ---
    // Visual goals: silky trails, neon rainbow, additive glow.

    let particles = [];

    const CAP = 2400;
    const BG = { h: 240, s: 20, b: 4 }; // very dark, near-black

    const emitter = {
      pos: null,
      prev: null,
      v: null,
      entered: false,
      demoT: 0,
      history: [],
      historyMax: 22
    };

    function setup() {
      createCanvas(windowWidth, windowHeight);
      pixelDensity(Math.min(2, window.devicePixelRatio || 1));
      colorMode(HSB, 360, 100, 100, 100);
      noFill();
      strokeCap(ROUND);

      emitter.pos = createVector(width * 0.5, height * 0.5);
      emitter.prev = emitter.pos.copy();
      emitter.v = createVector(0, 0);

      // Start with a clean, dark base.
      background(0, 0, 0);
    }

    function draw() {
      // Fade the previous frame slightly for long trails.
      // Lower alpha => longer trails.
      blendMode(BLEND);
      noStroke();
      fill(BG.h, BG.s, BG.b, 10);
      rect(0, 0, width, height);

      // Update emitter target: mouse when available, otherwise demo orbit.
      updateEmitter();

      const speed = emitter.v.mag();
      const speedN = constrain(speed / 22, 0, 1);

      // Emission intensity: faster movement => more particles.
      // Click/hold boosts emission + glow.
      const boost = mouseIsPressed ? 1.8 : 1.0;
      const baseRate = lerp(3, 18, speedN) * boost;

      spawnAlongHistory(baseRate);

      // Draw particles additively for glow.
      blendMode(ADD);
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        p.draw();
        if (p.dead) particles.splice(i, 1);
      }

      // Performance cap.
      if (particles.length > CAP) {
        particles.splice(0, particles.length - CAP);
      }

      // Return to normal blending for any future UI.
      blendMode(BLEND);
    }

    function updateEmitter() {
      const inside = mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height;
      const validMouse = inside && !(mouseX === 0 && mouseY === 0);

      emitter.prev.set(emitter.pos);

      if (validMouse) {
        emitter.entered = true;
        // Smooth follow for silkiness.
        const target = createVector(mouseX, mouseY);
        emitter.pos.lerp(target, 0.55);
      } else {
        // Autonomous demo orbit when idle / mouse not yet entered.
        emitter.demoT += 0.014;
        const r = min(width, height) * 0.18;
        const cx = width * 0.5;
        const cy = height * 0.5;

        const x = cx + cos(emitter.demoT * 1.0) * r * 1.15 + cos(emitter.demoT * 2.3) * r * 0.18;
        const y = cy + sin(emitter.demoT * 0.9) * r * 0.95 + sin(emitter.demoT * 1.9) * r * 0.22;

        // Gently converge (avoid snapping).
        emitter.pos.lerp(createVector(x, y), 0.08);
      }

      emitter.v = p5.Vector.sub(emitter.pos, emitter.prev);

      // Store a short history to spawn along the path (ribbon continuity).
      emitter.history.push(emitter.pos.copy());
      if (emitter.history.length > emitter.historyMax) emitter.history.shift();
    }

    function spawnAlongHistory(rate) {
      // Spawn across the last few positions so fast motion doesn't create gaps.
      const n = emitter.history.length;
      if (n < 2) return;

      // A little extra density when moving fast.
      const extra = map(constrain(emitter.v.mag(), 0, 30), 0, 30, 0, 10);
      let count = Math.floor(rate + extra);

      // Clamp to prevent spikes.
      count = constrain(count, 2, mouseIsPressed ? 48 : 34);

      for (let i = 0; i < count; i++) {
        // Bias spawns towards the head but still along the ribbon.
        const t = pow(random(), 0.45); // 0..1, biased toward 1
        const idx = floor(lerp(0, n - 1, t));
        const pos = emitter.history[idx];

        // Velocity: mostly in direction of motion, with slight curl/jitter.
        const mv = emitter.v.copy();
        const mvMag = mv.mag();
        if (mvMag < 0.001) mv.set(1, 0);
        mv.normalize();

        const tangent = createVector(-mv.y, mv.x);
        const swirl = tangent.mult(random(-1, 1) * (0.6 + mvMag * 0.05));

        const vel = mv.mult(random(0.6, 4.2) + mvMag * 0.12)
          .add(swirl)
          .add(p5.Vector.random2D().mult(random(0.2, 1.4)));

        const hue = (frameCount * 2.2 + i * 4.5) % 360;
        particles.push(new Particle(pos.x, pos.y, vel, hue));
      }
    }

    class Particle {
      constructor(x, y, vel, hue) {
        this.pos = createVector(x, y);
        this.prev = this.pos.copy();
        this.vel = vel.copy();

        this.hue = hue;
        this.sat = random(82, 100);
        this.bri = random(88, 100);

        this.life = random(36, 84);
        this.maxLife = this.life;

        // Streak length depends on motion at birth.
        this.thick = random(0.9, 2.4) * (mouseIsPressed ? 1.15 : 1.0);
        this.drag = random(0.88, 0.94);

        this.dead = false;
      }

      update() {
        this.prev.set(this.pos);

        // Mild noise-like jitter keeps it silky.
        const j = p5.Vector.random2D().mult(0.15);
        this.vel.add(j);

        this.pos.add(this.vel);
        this.vel.mult(this.drag);

        this.life -= 1;
        if (this.life <= 0) this.dead = true;

        // Kill if way out of bounds.
        const m = 80;
        if (this.pos.x < -m || this.pos.x > width + m || this.pos.y < -m || this.pos.y > height + m) {
          this.dead = true;
        }
      }

      draw() {
        const a = map(this.life, 0, this.maxLife, 0, 70);
        const glow = mouseIsPressed ? 1.2 : 1.0;

        // Core streak
        stroke(this.hue, this.sat, this.bri, a * glow);
        strokeWeight(this.thick);
        line(this.prev.x, this.prev.y, this.pos.x, this.pos.y);

        // Soft halo (cheap: second stroke, slightly thicker and lower alpha)
        stroke(this.hue, min(100, this.sat + 4), 100, a * 0.22 * glow);
        strokeWeight(this.thick * 3.2);
        line(this.prev.x, this.prev.y, this.pos.x, this.pos.y);
      }
    }

    function keyPressed() {
      if (key === 'c' || key === 'C') {
        blendMode(BLEND);
        background(0, 0, 0);
        particles = [];
      }
    }

    function windowResized() {
      // Preserve the feel of trails: don't hard-clear on resize.
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
