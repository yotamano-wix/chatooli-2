<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>p5 Animation Tool</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.3/p5.min.js"></script>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #0a0a0a; 
      font-family: 'Courier New', monospace;
    }
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      line-height: 1.6;
      pointer-events: none;
      z-index: 10;
      background: rgba(0, 0, 0, 0.5);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .mode { color: #ff006e; font-weight: bold; }
    .key { color: #3a86ff; }
  </style>
</head>
<body>
  <div id="info">
    <div><span class="mode">MODE:</span> <span id="modeName">Particles</span></div>
    <div style="margin-top: 10px;">
      <span class="key">1-6</span> Change mode<br>
      <span class="key">SPACE</span> Clear canvas<br>
      <span class="key">MOUSE</span> Draw/Interact<br>
      <span class="key">C</span> Toggle color mode<br>
      <span class="key">+/-</span> Size up/down
    </div>
  </div>

  <script>
    let mode = 0;
    let particles = [];
    let hueOffset = 0;
    let brushSize = 30;
    let colorMode = 'rainbow';
    let trailOpacity = 10;
    
    const modes = [
      'Particles',
      'Flow Field',
      'Spirograph',
      'Kaleidoscope',
      'Lightning',
      'Waves'
    ];

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 100);
      background(10);
    }

    function draw() {
      // Subtle trail effect
      fill(10, 10, 10, trailOpacity);
      noStroke();
      rect(0, 0, width, height);
      
      hueOffset = (hueOffset + 0.5) % 360;
      
      // Execute current mode
      switch(mode) {
        case 0: drawParticles(); break;
        case 1: drawFlowField(); break;
        case 2: drawSpirograph(); break;
        case 3: drawKaleidoscope(); break;
        case 4: drawLightning(); break;
        case 5: drawWaves(); break;
      }
      
      // Update and draw particles for modes that use them
      if (mode === 0 || mode === 1) {
        updateParticles();
      }
    }

    function drawParticles() {
      if (mouseIsPressed) {
        for (let i = 0; i < 3; i++) {
          particles.push({
            x: mouseX + random(-10, 10),
            y: mouseY + random(-10, 10),
            vx: random(-2, 2),
            vy: random(-2, 2),
            life: 100,
            hue: getHue(),
            size: random(3, brushSize / 3)
          });
        }
      }
    }

    function drawFlowField() {
      if (mouseIsPressed) {
        let angle = noise(mouseX * 0.01, mouseY * 0.01, frameCount * 0.01) * TWO_PI * 2;
        for (let i = 0; i < 2; i++) {
          particles.push({
            x: mouseX,
            y: mouseY,
            vx: cos(angle) * 2,
            vy: sin(angle) * 2,
            life: 150,
            hue: getHue(),
            size: random(2, 5)
          });
        }
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 1;
        
        // Add subtle noise to movement
        p.vx += random(-0.1, 0.1);
        p.vy += random(-0.1, 0.1);
        
        // Draw particle
        let alpha = map(p.life, 0, 100, 0, 90);
        fill(p.hue, 80, 90, alpha);
        noStroke();
        circle(p.x, p.y, p.size);
        
        // Remove dead particles
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
      
      // Cap particle count
      if (particles.length > 3000) {
        particles.splice(0, particles.length - 3000);
      }
    }

    function drawSpirograph() {
      if (mouseIsPressed) {
        push();
        translate(mouseX, mouseY);
        
        let arms = 8;
        let radius = brushSize * 2;
        let angle = frameCount * 0.05;
        
        for (let i = 0; i < arms; i++) {
          let a = (TWO_PI / arms) * i + angle;
          let x = cos(a) * radius;
          let y = sin(a) * radius;
          
          stroke(getHue(i * 20), 80, 90, 50);
          strokeWeight(3);
          line(0, 0, x, y);
          
          fill(getHue(i * 20), 80, 90, 70);
          noStroke();
          circle(x, y, 8);
        }
        pop();
      }
    }

    function drawKaleidoscope() {
      if (mouseIsPressed) {
        let segments = 12;
        let centerX = width / 2;
        let centerY = height / 2;
        let dx = mouseX - centerX;
        let dy = mouseY - centerY;
        
        for (let i = 0; i < segments; i++) {
          push();
          translate(centerX, centerY);
          rotate((TWO_PI / segments) * i);
          
          // Draw in each segment
          fill(getHue(i * 10), 80, 90, 60);
          noStroke();
          circle(dx, dy, brushSize);
          
          // Mirror
          circle(dx, -dy, brushSize * 0.7);
          
          pop();
        }
      }
    }

    function drawLightning() {
      if (mouseIsPressed) {
        let segments = 15;
        let x = mouseX;
        let y = mouseY;
        let prevX = pmouseX;
        let prevY = pmouseY;
        
        stroke(getHue(), 80, 100, 80);
        strokeWeight(2);
        noFill();
        
        beginShape();
        vertex(prevX, prevY);
        for (let i = 0; i < segments; i++) {
          let t = i / segments;
          let mx = lerp(prevX, x, t) + random(-brushSize, brushSize);
          let my = lerp(prevY, y, t) + random(-brushSize, brushSize);
          vertex(mx, my);
        }
        vertex(x, y);
        endShape();
        
        // Glow effect
        for (let i = 0; i < 3; i++) {
          stroke(getHue(), 70, 90, 20 - i * 5);
          strokeWeight(6 + i * 4);
          line(prevX, prevY, x, y);
        }
      }
    }

    function drawWaves() {
      if (mouseIsPressed) {
        let waves = 5;
        let waveLength = brushSize * 3;
        
        for (let w = 0; w < waves; w++) {
          stroke(getHue(w * 30), 80, 90, 40);
          strokeWeight(2);
          noFill();
          
          beginShape();
          for (let i = -10; i <= 10; i++) {
            let x = mouseX + i * 10;
            let y = mouseY + sin(i * 0.5 + frameCount * 0.1 + w) * waveLength;
            vertex(x, y);
          }
          endShape();
        }
      }
    }

    function getHue(offset = 0) {
      if (colorMode === 'rainbow') {
        return (hueOffset + offset) % 360;
      } else if (colorMode === 'neon') {
        let hues = [320, 180, 60, 220, 280];
        return hues[floor((hueOffset + offset) / 72) % hues.length];
      } else { // monochrome
        return 200; // blue
      }
    }

    function keyPressed() {
      // Mode selection
      if (key >= '1' && key <= '6') {
        mode = parseInt(key) - 1;
        document.getElementById('modeName').textContent = modes[mode];
        background(10);
        particles = [];
      }
      
      // Clear canvas
      if (key === ' ') {
        background(10);
        particles = [];
      }
      
      // Toggle color mode
      if (key === 'c' || key === 'C') {
        let colorModes = ['rainbow', 'neon', 'monochrome'];
        let idx = colorModes.indexOf(colorMode);
        colorMode = colorModes[(idx + 1) % colorModes.length];
      }
      
      // Brush size
      if (key === '+' || key === '=') {
        brushSize = min(brushSize + 5, 100);
      }
      if (key === '-' || key === '_') {
        brushSize = max(brushSize - 5, 10);
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      background(10);
    }
  </script>
</body>
</html>