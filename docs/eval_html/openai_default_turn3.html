<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js Subtle Bloom</title>
  <style>
    html, body { margin: 0; height: 100%; background: #05060a; overflow: hidden; }
    canvas { display: block; }
    .hint{
      position: fixed; left: 12px; bottom: 12px;
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: rgba(255,255,255,0.7);
      padding: 10px 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      backdrop-filter: blur(6px);
      user-select: none;
    }
  </style>

  <!-- Import maps: Three + postprocessing addons -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div class="hint">
    Drag: orbit • Wheel: zoom • Move mouse: subtle lighting response
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Postprocessing
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05060a);
    scene.fog = new THREE.Fog(0x05060a, 8, 28);

    const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 200);
    camera.position.set(0, 1.2, 7.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05; // small lift helps bloom read without being blown out
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 3;
    controls.maxDistance = 18;

    // Lights (keep some bright highlights so bloom has something to grab)
    const ambient = new THREE.AmbientLight(0xffffff, 0.22);
    scene.add(ambient);

    const key = new THREE.DirectionalLight(0xa9d6ff, 1.25);
    key.position.set(4, 6, 3);
    scene.add(key);

    const rim = new THREE.PointLight(0xff6bd6, 14, 30);
    rim.position.set(-4, 1.5, -2);
    scene.add(rim);

    // A glowy-ish object set: a knot + some emissive accents
    const knotGeo = new THREE.TorusKnotGeometry(1.2, 0.38, 220, 28);
    const knotMat = new THREE.MeshStandardMaterial({
      color: 0x0b1020,
      metalness: 0.85,
      roughness: 0.22,
      emissive: 0x110817,
      emissiveIntensity: 0.35
    });
    const knot = new THREE.Mesh(knotGeo, knotMat);
    knot.position.y = 0.35;
    scene.add(knot);

    // Accents: small emissive spheres around (give bloom something bright but subtle)
    const accents = new THREE.Group();
    const accGeo = new THREE.SphereGeometry(0.08, 24, 16);
    for (let i = 0; i < 42; i++) {
      const hue = (i / 42) * 360;
      const col = new THREE.Color().setHSL(hue / 360, 0.85, 0.62);

      const m = new THREE.MeshStandardMaterial({
        color: 0x05060a,
        metalness: 0.0,
        roughness: 0.35,
        emissive: col,
        emissiveIntensity: 1.6
      });

      const s = new THREE.Mesh(accGeo, m);
      const a = i * 0.35;
      const r = 2.2 + 0.6 * Math.sin(i * 1.7);
      s.position.set(Math.cos(a) * r, (Math.sin(i * 0.8) * 0.9) + 0.2, Math.sin(a) * r);
      accents.add(s);
    }
    scene.add(accents);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.CylinderGeometry(5.5, 6.2, 0.7, 64, 1, true),
      new THREE.MeshStandardMaterial({
        color: 0x070914,
        metalness: 0.15,
        roughness: 0.95,
        emissive: 0x04040a,
        emissiveIntensity: 0.25
      })
    );
    ground.position.y = -0.2;
    scene.add(ground);

    // --- Postprocessing Composer + UnrealBloomPass ---
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    // Subtle but visible bloom settings:
    // strength: intensity of glow
    // radius: spread (blur size)
    // threshold: cutoff; lower means more things bloom
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(innerWidth, innerHeight),
      0.65, // strength (subtle but noticeable)
      0.65, // radius
      0.85  // threshold (keeps it subtle; only bright highlights bloom)
    );
    composer.addPass(bloomPass);

    // Interaction: mouse gently steers a light + boosts emissive a touch
    const mouse = new THREE.Vector2(0.0, 0.0);
    window.addEventListener('pointermove', (e) => {
      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -((e.clientY / innerHeight) * 2 - 1);
    }, { passive: true });

    let t0 = performance.now();
    function animate(now) {
      const t = (now - t0) * 0.001;

      // motion
      knot.rotation.x = t * 0.35;
      knot.rotation.y = t * 0.55;
      accents.rotation.y = t * 0.22;
      accents.rotation.x = Math.sin(t * 0.3) * 0.08;

      // mouse-driven lighting (keeps bloom "alive" subtly)
      rim.position.x = THREE.MathUtils.lerp(rim.position.x, -4 + mouse.x * 2.2, 0.06);
      rim.position.y = THREE.MathUtils.lerp(rim.position.y,  1.5 + mouse.y * 1.2, 0.06);

      // tiny breathing of bloom strength
      bloomPass.strength = 0.58 + 0.12 * (0.5 + 0.5 * Math.sin(t * 0.9));

      controls.update();
      composer.render(); // render via composer (bloom applied to whole scene)
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    function onResize() {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);

      // keep bloom internal resolution updated too
      bloomPass.setSize(innerWidth, innerHeight);
    }
    window.addEventListener('resize', onResize);
  </script>
</body>
</html>