<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Icosahedron + Dual Torus Knots</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #05070b; }
    canvas { display: block; }
    .hud {
      position: fixed; left: 12px; bottom: 12px;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: rgba(255,255,255,0.75);
      user-select: none; pointer-events: none;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 10px 12px; border-radius: 10px;
      backdrop-filter: blur(8px);
    }
    .hud b { color: rgba(255,255,255,0.92); font-weight: 650; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="hud">
    <b>Drag</b> orbit • <b>Scroll</b> zoom • <b>Shift+Drag</b> pan<br/>
    Two torus knots: one central, one smaller <b>orbiting the icosahedron</b>.
  </div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

  // -----------------------------
  // Renderer / Scene / Camera
  // -----------------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x05070b);
  scene.fog = new THREE.Fog(0x05070b, 8, 30);

  const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 120);
  camera.position.set(0, 1.6, 7.5);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;
  controls.target.set(0, 0.2, 0);

  // -----------------------------
  // Lighting
  // -----------------------------
  const ambient = new THREE.AmbientLight(0xb8c6ff, 0.28);
  scene.add(ambient);

  const keyLight = new THREE.DirectionalLight(0xffffff, 1.15);
  keyLight.position.set(4.5, 5.5, 3.5);
  scene.add(keyLight);

  const rimLight = new THREE.DirectionalLight(0x79a7ff, 0.55);
  rimLight.position.set(-6.0, 2.0, -4.5);
  scene.add(rimLight);

  const point = new THREE.PointLight(0xff5bd6, 0.9, 30);
  point.position.set(0, 2.2, 0);
  scene.add(point);

  // -----------------------------
  // Subtle starfield
  // -----------------------------
  const starsGeo = new THREE.BufferGeometry();
  const starCount = 1800;
  const pos = new Float32Array(starCount * 3);
  for (let i = 0; i < starCount; i++) {
    const r = 22 * Math.cbrt(Math.random());
    const u = Math.random();
    const v = Math.random();
    const theta = 2 * Math.PI * u;
    const phi = Math.acos(2 * v - 1);
    pos[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
    pos[i * 3 + 1] = r * Math.cos(phi) * 0.75;
    pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
  }
  starsGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const starsMat = new THREE.PointsMaterial({
    color: 0xcfe2ff,
    size: 0.015,
    transparent: true,
    opacity: 0.6,
    depthWrite: false
  });
  const stars = new THREE.Points(starsGeo, starsMat);
  scene.add(stars);

  // -----------------------------
  // Core group (center of the world)
  // -----------------------------
  const core = new THREE.Group();
  scene.add(core);

  // Icosahedron
  const icoGeo = new THREE.IcosahedronGeometry(1.1, 1);
  const icoMat = new THREE.MeshStandardMaterial({
    color: 0x8dd7ff,
    emissive: 0x08324a,
    metalness: 0.55,
    roughness: 0.22,
    transparent: true,
    opacity: 0.92
  });
  const icosahedron = new THREE.Mesh(icoGeo, icoMat);
  core.add(icosahedron);

  // Wireframe overlay for detail
  const wire = new THREE.Mesh(
    icoGeo,
    new THREE.MeshBasicMaterial({
      color: 0x0fe0ff,
      wireframe: true,
      transparent: true,
      opacity: 0.18
    })
  );
  wire.scale.setScalar(1.01);
  core.add(wire);

  // Main torus knot (central)
  const knotGeo = new THREE.TorusKnotGeometry(1.7, 0.12, 420, 24, 2, 3);
  const knotMat = new THREE.MeshStandardMaterial({
    color: 0xff3aa6,
    emissive: 0x2a0014,
    metalness: 0.85,
    roughness: 0.18
  });
  const mainKnot = new THREE.Mesh(knotGeo, knotMat);
  core.add(mainKnot);

  // ---------------------------------------
  // SECOND smaller torus knot orbiting
  // ---------------------------------------
  // Put it in an orbit pivot group so we can rotate the pivot to orbit around the core.
  const orbitPivot = new THREE.Group();
  core.add(orbitPivot);

  const smallKnotGeo = new THREE.TorusKnotGeometry(0.55, 0.075, 280, 18, 3, 5);
  const smallKnotMat = new THREE.MeshStandardMaterial({
    color: 0x5dff9a,      // different color
    emissive: 0x062014,
    metalness: 0.65,
    roughness: 0.25
  });
  const smallKnot = new THREE.Mesh(smallKnotGeo, smallKnotMat);

  // Initial offset from center = orbit radius
  const orbitRadius = 2.75;
  smallKnot.position.set(orbitRadius, 0.25, 0);
  orbitPivot.add(smallKnot);

  // A faint orbit ring for readability (optional, subtle)
  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(orbitRadius, 0.008, 10, 220),
    new THREE.MeshBasicMaterial({ color: 0x5dff9a, transparent: true, opacity: 0.12 })
  );
  ring.rotation.x = Math.PI * 0.5;
  orbitPivot.add(ring);

  // -----------------------------
  // Postprocessing (Bloom)
  // -----------------------------
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.05, 0.55, 0.85);
  composer.addPass(bloom);

  // -----------------------------
  // Interaction: gentle pointer light shift
  // -----------------------------
  const mouse = new THREE.Vector2(0, 0);
  window.addEventListener('pointermove', (e) => {
    mouse.x = (e.clientX / innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / innerHeight) * 2 + 1;
  }, { passive: true });

  // -----------------------------
  // Animate
  // -----------------------------
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    controls.update();

    // Subtle whole-scene drift
    stars.rotation.y = t * 0.02;

    // Core motion
    icosahedron.rotation.y = t * 0.35;
    icosahedron.rotation.x = t * 0.18;

    wire.rotation.copy(icosahedron.rotation);

    mainKnot.rotation.y = -t * 0.22;
    mainKnot.rotation.x = t * 0.16;

    // Orbiting small knot:
    // - orbitPivot rotates to move the knot around the icosahedron
    // - smallKnot rotates itself for extra complexity
    orbitPivot.rotation.y = t * 0.55;
    orbitPivot.rotation.x = Math.sin(t * 0.35) * 0.22;
    smallKnot.rotation.x = t * 0.9;
    smallKnot.rotation.y = -t * 1.1;

    // A tiny bob for life
    smallKnot.position.y = 0.25 + Math.sin(t * 1.6) * 0.18;

    // Pointer-reactive point light
    point.position.x = mouse.x * 2.2;
    point.position.z = 0.6 + mouse.y * 2.0;

    composer.render();
  }
  animate();

  // -----------------------------
  // Resize
  // -----------------------------
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
    bloom.setSize(innerWidth, innerHeight);
  });
</script>
</body>
</html>