<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Icosahedron + Orbiting Torus Knot</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #0a0a0a; }
    canvas { display: block; }
    .hint {
      position: fixed; left: 12px; bottom: 12px;
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: rgba(255,255,255,0.65);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px 12px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      user-select: none;
      pointer-events: none;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="hint">Drag to orbit • Scroll to zoom • Move mouse to subtly steer orbit</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // --- renderer ---
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  document.body.appendChild(renderer.domElement);

  // --- scene ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0a0a);

  // subtle fog for depth
  scene.fog = new THREE.Fog(0x0a0a0a, 8, 30);

  // --- camera ---
  const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 100);
  camera.position.set(0, 1.2, 8.5);

  // --- controls ---
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;

  // --- lighting ---
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));

  const keyLight = new THREE.DirectionalLight(0xffffff, 1.15);
  keyLight.position.set(4, 6, 2);
  scene.add(keyLight);

  const rimLight = new THREE.PointLight(0x66ccff, 1.2, 30);
  rimLight.position.set(-6, 2, -6);
  scene.add(rimLight);

  // --- main object: icosahedron ---
  const icoGeo = new THREE.IcosahedronGeometry(1.6, 2);
  const icoMat = new THREE.MeshStandardMaterial({
    color: 0x7cf5ff,
    metalness: 0.35,
    roughness: 0.22,
    emissive: new THREE.Color(0x06353a),
    emissiveIntensity: 0.75
  });
  const icosahedron = new THREE.Mesh(icoGeo, icoMat);
  icosahedron.position.set(0, 0, 0);
  scene.add(icosahedron);

  // --- orbiting object: smaller torus knot (different color) ---
  const orbitPivot = new THREE.Group();
  scene.add(orbitPivot);

  const knotGeo = new THREE.TorusKnotGeometry(0.45, 0.14, 180, 24);
  const knotMat = new THREE.MeshStandardMaterial({
    color: 0xff4fd8,          // different color
    metalness: 0.55,
    roughness: 0.18,
    emissive: new THREE.Color(0x2a001c),
    emissiveIntensity: 0.9
  });
  const orbitKnot = new THREE.Mesh(knotGeo, knotMat);

  // set initial orbit radius
  const orbitRadius = 3.0;
  orbitKnot.position.set(orbitRadius, 0.2, 0);
  orbitPivot.add(orbitKnot);

  // optional: a faint orbit ring to read motion
  const ringGeo = new THREE.RingGeometry(orbitRadius - 0.01, orbitRadius + 0.01, 128);
  const ringMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.06,
    side: THREE.DoubleSide
  });
  const orbitRing = new THREE.Mesh(ringGeo, ringMat);
  orbitRing.rotation.x = Math.PI * 0.5;
  scene.add(orbitRing);

  // --- background stars (tiny points) ---
  {
    const starCount = 900;
    const pos = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      // place stars in a shell
      const r = 10 + Math.random() * 25;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
      pos[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
      pos[i*3+1] = r * Math.cos(phi);
      pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
    }
    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const m = new THREE.PointsMaterial({ color: 0xffffff, size: 0.015, transparent: true, opacity: 0.7 });
    const stars = new THREE.Points(g, m);
    scene.add(stars);
  }

  // --- interaction: mouse steers the orbit plane slightly ---
  const mouse = new THREE.Vector2(0, 0);
  const targetTilt = new THREE.Vector2(0, 0);
  window.addEventListener('pointermove', (e) => {
    const nx = (e.clientX / innerWidth) * 2 - 1;
    const ny = (e.clientY / innerHeight) * 2 - 1;
    mouse.set(nx, ny);
    targetTilt.set(-ny * 0.25, nx * 0.35);
  }, { passive: true });

  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    // main object motion
    icosahedron.rotation.y = t * 0.45;
    icosahedron.rotation.x = Math.sin(t * 0.35) * 0.18;

    // orbit motion (the pivot rotates; the knot also spins)
    orbitPivot.rotation.y = t * 0.9;
    orbitPivot.rotation.x = Math.sin(t * 0.55) * 0.15;

    // mouse-influenced tilt (smoothed)
    orbitPivot.rotation.x += (targetTilt.x - orbitPivot.rotation.x) * 0.03;
    orbitPivot.rotation.z += (targetTilt.y - orbitPivot.rotation.z) * 0.03;

    orbitKnot.rotation.x = t * 1.2;
    orbitKnot.rotation.y = t * 1.7;

    // gentle bobbing along orbit
    orbitKnot.position.y = 0.35 * Math.sin(t * 1.3);

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // --- resize ---
  addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  });
</script>
</body>
</html>